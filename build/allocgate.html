<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8">
  <title>
   Allocgate is coming in Zig 0.9, and you will have to change your code — My Homepage
  </title>
  <style>
   body { font-size: 1.1em; line-height: 1.5em; max-width: 45em; margin: auto; padding-bottom: 5%; }
      h1 { font-size: 2em; }
      h1, h2 { line-height: 1.1em; }
      time { display: block; text-align: center; font-size: 0.8em; }
      pre { line-height: 1em; margin: auto; }
      p>code { background-color: #eee; margin: 2px; padding: 3px; }
      pre { background-color: #eee; margin: 2px; padding: 10px; }
      img.sharp { image-rendering: pixelated; }
      .proof { margin-left: 2em; }
      table { border-collapse: collapse; width: 100%; }
      td { border: 1px solid black; padding: 0.5em; vertical-align: top; }
  </style>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="generator" content="soupault">
 </head>
 <body>
  <article>
   <h1>
    Allocgate is coming in Zig 0.9, and you will have to change your code
   </h1>
   <p>
    <time datetime="2021-12-15">Date: 2021-12-15</time>
   </p>
   <p>
    Version 0.9 of <a href="https://ziglang.org">the Zig programming language</a> is planned to release in about a
week. One of the major changes coming in this release is a restructuring of how allocators work,
which has been termed <a href="https://github.com/ziglang/zig/issues/10052">Allocgate</a>. This is a breaking
change to the <code>Allocator</code> API provided by the standard library, so pretty much any code that uses
allocators will have to be updated in response. I hope to use this article to explain the
justification for this change and what steps you need to take to adjust your code.
   </p>
   <p>
    The TL;DR is:
   </p>
   <ul>
    <li>
     Where you previously passed around <code>*Allocator</code> to functions that need to
allocate, you now pass around <code>Allocator</code> directly. <code>Allocator</code> is now a
struct, which is the size of two pointers.
    </li>
    <li>
     When you construct an allocator (such as
<code>var gpa: std.heap.GeneralPurposeAllocator(.{});</code>), you call
<code>gpa.allocator()</code> to get the type-erased allocator implementation
rather than writing <code>&amp;gpa.allocator</code>.
    </li>
   </ul>
   <p>
    Unless you are writing your own allocator, this should be all you need to change.
   </p>
   <h2>
    Two ways to approach polymorphism
   </h2>
   <p>
    Zig’s allocators rely on dynamic dispatch. The choice of allocation and deallocation functions is
not known until runtime, so if you want to write code that is agnostic to the user’s choice of
allocator (and you generally do when writing library code), you need to accept these functions as a
parameter in some way. Most languages use a structure called a <em>virtual function table</em> (vtable)
which stores the addresses of each dynamically-known function. Zig’s standard library provides a
variety of allocators (such as <code>ArenaAllocator</code> and <code>GeneralPurposeAllocator</code>), each of which has
some associated state along with a set of functions (<code>alloc</code>, <code>resize</code>, and <code>free</code>) which operate on
that state to work as a memory allocator. The addresses of these three functions are collected into
an “allocator vtable”.
   </p>
   <p>
    Any polymorphic object’s state needs to be passed along with its vtable somehow. One way to do it is
to represent an object as a pair of pointers: one to the object’s fields, and one to a vtable which
knows how to operate on those fields. I’ll follow Rust’s terminology and call this <code>(impl, vtable)</code>
pair a “fat pointer”.
   </p>
   <pre><code> Dynamic           Object
----------        ----------
| impl   | -----&gt; | fields |
|--------|        | ...    |
| vtable | ---.   ----------
----------    |
              |    Vtable
              |   ----------
              `-&gt; | alloc  |
                  | resize |
                  | free   |
                  ----------
</code></pre>
   <p>
    Another way would be to store a separate copy of the vtable in every object. By knowing its address,
the vtable’s functions would be able to deduce the address of the struct containing them, an
operation sometimes called <code>container_of</code> in C and provided by Zig under the name <code>@fieldParentPtr</code>.
Indeed, this is such a common use of this builtin that the technique is commonly described as just
“the <code>@fieldParentPtr</code> idiom.”
   </p>
   <pre><code>                   Object
                  --------------
                  | fields     |
 Dynamic          | ...        |
----------        | ---------- |
| vtable | -------&gt; | alloc  | |
----------        | | resize | |
                  | | free   | |
                  | ---------- |
                  | ...        |
                  --------------
</code></pre>
   <p>
    (We could also imagine a third solution in which the object contains a pointer to the vtable in its
fields, and we pass around a pointer to that pointer. This has the advantage of sharing vtables,
while still requiring only a single pointer to be passed around. However, this also means we would
need a double indirection to access the vtable, which would be more expensive.)
   </p>
   <h2>
    Polymorphic allocators in Zig
   </h2>
   <p>
    Without stooping so low as to actually <em>benchmark</em>, what might the respective advantages of these
two approaches be?
   </p>
   <ul>
    <li>
     Using fat pointers, we get to make fewer copies of the vtable. Every polymorphic value can point
to the same one, which saves memory and allows dynamic objects to be smaller.
    </li>
    <li>
     With the <code>@fieldParentPtr</code> approach, we’re able to pass a dynamic object around as just a single
pointer. This improves performance and saves memory for any struct that needs to hold a dynamic
allocator (notably, most <code>std</code> containers).
    </li>
   </ul>
   <p>
    In the case of allocators, it might seem like the <code>@fieldParentPtr</code> approach would win out. After
all, the average program passes relatively many pointers to relatively few different allocators, so
making the latter large at the expense of keeping the former small is a sensible trade-off.
   </p>
   <p>
    However, as it turns out, this approach has a performance problem with has to do with
devirtualization. Virtual function calls are more expensive than calls to known functions for a
number of reasons, so LLVM would like to rewrite them to static calls anywhere it can prove that a
function pointer always has a particular value. This becomes more difficult when the function
pointer lives inside a structure like <code>GeneralPurposeAllocator</code>. Zig’s <code>struct</code>s don’t even have
compile-time encapsulation, much less runtime encapsulation. There is nothing stopping you from
reaching into your <code>GeneralPurposeAllocator</code> and changing the vtable functions to do something else.
It would definitely be against <code>std</code>‘s contract, but it wouldn’t immediately cause undefined
behavior. This means any code which reads vtables out of the embedded <code>Allocator</code> has to be
defensive against the possibility that the vtable was modified, making devirtualization impossible.
   </p>
   <p>
    In contrast, when using fat pointers, the vtables are shared constant objects, and a new fat pointer
is constructed on every call to <code>gpa.allocator()</code>. So while we incur the cost of passing around a
larger fat pointer, the allocation and deallocation functions potentially become much faster to
call.
   </p>
   <h2>
    Allocgate
   </h2>
   <p>
    As far as I can tell, the performance issues of the <code>@fieldParentPtr</code> approach were first noticed
<a href="https://github.com/ziglang/zig/issues/10037">about two months ago</a> in the <code>std.rand</code> API, which
uses a similar approach to allow code to be polymorphic over the caller’s choice of RNG algorithm
(perhaps the performance issues were more apparent here because RNG algorithms are designed to have
high throughput, so the relative overhead of indirect calls is larger). It was noted in that issue
that any other code using this approach would suffer the same problem.
   </p>
   <p>
    With Allocgate, the <code>std.mem.Allocator</code> API was also changed from embedded vtables to fat pointers.
This is the reason behind the two API changes I mentioned at the beginning of the article:
<code>Allocator</code> was changed from holding the vtable itself to being a fat pointer struct, and you call
<code>gpa.allocator()</code> instead of <code>&amp;gpa.allocator</code> because the vtable is no longer a field of the
allocator and you instead need to construct a fat pointer.
   </p>
   <p>
    This also happens to address a specific failure mode I have run into before, where instead of writing
   </p>
   <pre><code>var gpa = std.heap.GeneralPurposeAllocator(.{}){};
const alloc = &amp;gpa.allocator;
</code></pre>
   <p>
    the user writes:
   </p>
   <pre><code>var gpa = std.heap.GeneralPurposeAllocator(.{}){};
var alloc = gpa.allocator;
</code></pre>
   <p>
    This <em>copies</em> the allocator out of its parent struct and then attempts to call methods like
<code>alloc.alloc()</code>. This will generally compile correctly (since Zig will automatically take the
address of an object when calling a method that takes <code>self</code> by pointer), but causes undefined
behavior at runtime because <code>alloc</code> attempts to use <code>@fieldParentPtr</code> despite no longer being
contained in the struct it expects to be in. Post-Allocgate, this code instead becomes:
   </p>
   <pre><code>var gpa = std.heap.GeneralPurposeAllocator(.{}){};
const alloc = gpa.allocator();
</code></pre>
   <p>
    … which is pretty much impossible to silently get wrong.
   </p>
   <h2>
    What’s next for vtable-based polymorphism?
   </h2>
   <p>
    Allocgate has been <a href="https://github.com/ziglang/zig/pull/10055">merged into Zig’s master branch</a> and
should ship in Zig 0.9. This involved an impressive amount of work, with much of the standard
library needing to be changed. It should hopefully yield better performance for code that uses any
of the standard library’s allocator abstractions. Zig’s contributors have gone back and forth on the
specifics of the change, and looked at a number of benchmarks, but I’m sure they would welcome
additional data on this.
   </p>
   <p>
    I think this is a great example of the kind of ecosystem-wide improvements Zig can make as a
relatively young language that has yet to tie itself to any stability guarantees. It sucks for
language users who will have to change their code, of course, but hopefully they knew what they were
getting into. One of Zig’s principles is “avoid local maxima,” which, at this point in the
language’s evolution, means to be willing to move to a better solution even if it means breaking
backwards compatibility.
   </p>
   <p>
    A number of topics are also being discussed that have the potential to further improve the
performance and ergonomics of runtime polymorphism. For example, it could be that improvements to
Zig or LLVM’s aliasing model will make it easier to optimize virtual function calls (for example, by
making it possible to mark a particular field of a struct as immutable). Zig’s developers have also
expressed some interest in having first-class support for interfaces in the standard library or even
the language itself, which would make it easier for the user and reduce the burden of having to
modify every API in the standard library when changes like this are made.
   </p>
   <h2>
    Credit for the change
   </h2>
   <p>
    I had no personal involvement in Allocgate. I am simply an outsider who is interested in Zig and
thought others might benefit from an explanation of this change. Instead, I ought to credit:
   </p>
   <ul>
    <li>
     Andrew Kelley (<a href="https://github.com/andrewrk">@andrewrk</a>), creator of Zig and initial designer of
the allocator API;
    </li>
    <li>
     <a href="https://github.com/ominitay">@ominitay</a>, who first diagnosed the problem in <code>std.rand</code> and
provided benchmarks;
    </li>
    <li>
     Martin Wickham (<a href="https://github.com/SpexGuy">@SpecGuy</a>), who discovered the optimization problems
with LLVM and the need to move away from <code>@fieldParentPtr</code>-based APIs;
    </li>
    <li>
     Lee Cannon (<a href="https://github.com/leecannon">@leecannon</a>, who implemented the bulk of the change to
<code>Allocator</code>, including updating the entire standard library;
    </li>
    <li>
     and everyone else who contributed feedback, bug fixes, and benchmarks on the PR.
    </li>
   </ul>
  </article>
  <hr>
  <p>
   <img src="./buttons/trans-flag.png">
      <img src="./buttons/ace-flag.png">
  </p>
  <p>
   <a href="https://soupault.app/"><img src="./buttons/powered-by-soupault.png"></a>
      <img src="./buttons/firefox.gif">
      <img src="./buttons/any-browser.gif">
      <img src="./buttons/bookmark_this_page.gif">
  </p>
  <p>
   <a href="https://tailscale.com/"><img src="./buttons/tailscale.png" class="sharp"></a>
      <img src="./buttons/fediverse.gif" class="sharp">
      <a href="https://bitwarden.com/"><img src="./buttons/bitwarden.gif" class="sharp"></a>
      <img src="./buttons/latex.gif">
      <img src="./buttons/linux.gif">
      <img src="./buttons/sun.gif">
      <a href="https://archive.org/"><img src="./buttons/internetarchive.gif"></a>
      <img src="./buttons/antinft.gif">
      <img src="./buttons/iso8601.png">
  </p>
 </body>
</html>
